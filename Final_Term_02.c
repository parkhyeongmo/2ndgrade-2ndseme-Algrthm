{\rtf1\ansi\ansicpg949\cocoartf2636
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset129 AppleSDGothicNeo-Regular;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 // IP : 112.149.113.193\
\
/*\

\f1 \'c7\'d8\'b4\'e7
\f0  
\f1 \'b9\'ae\'c1\'a6\'bf\'a1\'bc\'ad
\f0  
\f1 \'b1\'d7\'b7\'a1\'c7\'c1\'c0\'c7
\f0  
\f1 \'bf\'ac\'b0\'e1\'bf\'e4\'bc\'d2
\f0  
\f1 \'b0\'b3\'bc\'f6\'bf\'cd
\f0  
\f1 \'b0\'a2
\f0  
\f1 \'bf\'ac\'b0\'e1\'bf\'e4\'bc\'d2\'bf\'a1
\f0  
\f1 \'c6\'f7\'c7\'d4\'b5\'c8
\f0  
\f1 \'c1\'a4\'c1\'a1\'c0\'c7
\f0  
\f1 \'b0\'b3\'bc\'f6\'b8\'a6
\f0  
\f1 \'b1\'b8\'c7\'cf\'b4\'c2\'b5\'a5
\f0  DFS 
\f1 \'be\'cb\'b0\'ed\'b8\'ae\'c1\'f2\'c0\'bb
\f0  
\f1 \'bb\'e7\'bf\'eb\'c7\'cf\'bf\'b4\'b4\'d9
\f0 .\
DFS
\f1 \'b4\'c2
\f0  
\f1 \'b1\'ed\'c0\'cc\'b8\'a6
\f0  
\f1 \'bf\'ec\'bc\'b1\'c0\'b8\'b7\'ce
\f0  
\f1 \'c5\'bd\'bb\'f6\'c7\'cf\'b4\'c2
\f0  
\f1 \'b1\'d7\'b7\'a1\'c7\'c1
\f0  
\f1 \'bc\'f8\'c8\'b8
\f0  
\f1 \'b9\'e6\'bd\'c4\'c0\'b8\'b7\'ce
\f0  
\f1 \'bf\'ac\'b0\'e1\'b5\'c8
\f0  
\f1 \'b8\'f0\'b5\'e7
\f0  
\f1 \'c1\'a4\'c1\'a1\'c0\'bb
\f0  
\f1 \'c5\'bd\'bb\'f6\'c7\'cf\'b0\'d4
\f0  
\f1 \'b5\'c8\'b4\'d9
\f0 . 
\f1 \'b6\'a7\'b9\'ae\'bf\'a1
\f0  
\f1 \'c7\'d1
\f0  
\f1 \'b9\'f8
\f0  DFS
\f1 \'b0\'a1
\f0  
\f1 \'bd\'c7\'c7\'e0\'b5\'c9
\f0  
\f1 \'b6\'a7
\f0 \

\f1 \'b9\'e6\'b9\'ae\'c7\'d1
\f0  
\f1 \'b3\'eb\'b5\'e5\'b8\'a6
\f0  
\f1 \'bf\'ac\'b0\'e1\'bf\'e4\'bc\'d2\'bf\'a1
\f0  
\f1 \'c6\'f7\'c7\'d4\'b5\'c8
\f0  
\f1 \'c1\'a4\'c1\'a1\'c0\'c7
\f0  
\f1 \'b0\'b3\'bc\'f6\'b7\'ce\'bc\'ad
\f0  
\f1 \'b9\'dd\'c8\'af
\f0  
\f1 \'b9\'de\'b0\'ed
\f0  
\f1 \'c3\'d1
\f0  
\f1 \'b8\'ee\'b9\'f8
\f0  DFS
\f1 \'b0\'a1
\f0  
\f1 \'bd\'c7\'c7\'e0\'b5\'c7\'b4\'c2\'c1\'f6\'b4\'c2
\f0  
\f1 \'bf\'ac\'b0\'e1\'bf\'e4\'bc\'d2\'c0\'c7
\f0  
\f1 \'b0\'b3\'bc\'f6\'b7\'ce\'bc\'ad
\f0  
\f1 \'b9\'dd\'c8\'af
\f0  
\f1 \'b9\'de\'be\'c6
\f0  
\f1 \'c3\'e2\'b7\'c2\'c7\'cf\'b0\'d4
\f0  
\f1 \'b5\'c8\'b4\'d9
\f0 .\
DFS
\f1 \'c0\'c7
\f0  
\f1 \'b0\'e6\'bf\'ec
\f0  
\f1 \'c0\'ce\'c1\'a2\'b8\'ae\'bd\'ba\'c6\'ae
\f0  
\f1 \'b1\'b8\'c1\'b6\'b7\'ce
\f0  
\f1 \'c7\'a5\'c7\'f6\'b5\'c8
\f0  
\f1 \'b1\'d7\'b7\'a1\'c7\'c1\'bf\'a1\'bc\'ad\'c0\'c7
\f0  
\f1 \'bc\'ba\'b4\'c9\'c0\'cc
\f0  O(n + m)
\f1 \'c0\'cc\'b1\'e2
\f0  
\f1 \'b6\'a7\'b9\'ae\'bf\'a1
\f0  
\f1 \'c7\'d8\'b4\'e7
\f0  
\f1 \'c7\'c1\'b7\'ce\'b1\'d7\'b7\'a5\'c0\'c7
\f0  
\f1 \'bc\'ba\'b4\'c9\'c0\'ba
\f0  O(n + m)
\f1 \'c0\'cc\'b4\'d9
\f0 .\
\
n = 
\f1 \'c1\'a4\'c1\'a1\'c0\'c7
\f0  
\f1 \'b0\'b3\'bc\'f6
\f0  / m = 
\f1 \'b0\'a3\'bc\'b1\'c0\'c7
\f0  
\f1 \'b0\'b3\'bc\'f6
\f0 \
\

\f1 \'b0\'a2
\f0  
\f1 \'bf\'ac\'b0\'e1\'bf\'e4\'bc\'d2\'bf\'a1
\f0  
\f1 \'c6\'f7\'c7\'d4\'b5\'c8
\f0  
\f1 \'c1\'a4\'c1\'a1\'c0\'c7
\f0  
\f1 \'b0\'b3\'bc\'f6\'b8\'a6
\f0  
\f1 \'b3\'bb\'b8\'b2\'c2\'f7\'bc\'f8\'c0\'b8\'b7\'ce
\f0  
\f1 \'c1\'a4\'b7\'c4\'c7\'cf\'b4\'c2
\f0  Sort
\f1 \'b4\'c2
\f0  
\f1 \'b9\'f6\'ba\'ed\'c1\'a4\'b7\'c4\'c0\'bb
\f0  
\f1 \'bb\'e7\'bf\'eb\'c7\'cf\'bf\'b4\'c0\'b8\'b8\'e7
\f0  
\f1 \'c3\'a4\'c1\'a1\'b4\'eb\'bb\'f3\'c0\'cc
\f0  
\f1 \'be\'c6\'b4\'cf\'b6\'f3\'b0\'ed
\f0  
\f1 \'c7\'cf\'bf\'a9
\f0  
\f1 \'c0\'a7\'c0\'c7
\f0  
\f1 \'b0\'e8\'bb\'ea\'bf\'a1\'bc\'ad
\f0 \

\f1 \'c1\'a6\'bf\'dc\'c7\'cf\'bf\'b4\'bd\'c0\'b4\'cf\'b4\'d9
\f0 . 
\f1 \'b9\'f6\'ba\'ed\'c1\'a4\'b7\'c4\'c0\'c7
\f0  
\f1 \'bc\'ba\'b4\'c9
\f0  : O(n^2) (
\f1 \'bf\'a9\'b1\'e2\'bc\'ad
\f0  n
\f1 \'c0\'ba
\f0  
\f1 \'c1\'a4\'c1\'a1\'c0\'c7
\f0  
\f1 \'b0\'b3\'bc\'f6\'b0\'a1
\f0  
\f1 \'be\'c6\'b4\'cf\'b6\'f3
\f0  
\f1 \'c1\'a4\'b7\'c4\'c7\'cf\'b4\'c2
\f0  
\f1 \'b9\'e8\'bf\'ad
\f0  
\f1 \'b3\'bb
\f0  
\f1 \'bf\'f8\'bc\'d2\'c0\'c7
\f0  
\f1 \'b0\'b3\'bc\'f6\'c0\'d4\'b4\'cf\'b4\'d9
\f0 .)\
\
*/\
\
#pragma warning(disable:4996)\
#include <stdio.h>\
#include <stdlib.h>\
#include <limits.h>\
\
typedef struct vertex \{\
\
	char name;\
	int label;\
	struct incidentList* L;\
\
\}V;\
\
typedef struct edge \{\
\
	struct vertex* v1;\
	struct vertex* v2;\
\
	int weight;\
\
\}E;\
\
typedef struct incidentList \{\
\
	struct edge* e;\
	struct incidentList* next;\
\
\}inList;\
\
typedef struct graph \{\
\
	struct vertex v[100];\
	struct edge e[1000];\
\
	int connected[100]; // 
\f1 \'bf\'ac\'b0\'e1\'bf\'e4\'bc\'d2\'c0\'c7
\f0  
\f1 \'c1\'a4\'c1\'a1
\f0  
\f1 \'b0\'b3\'bc\'f6
\f0  
\f1 \'c0\'fa\'c0\'e5\'c0\'bb
\f0  
\f1 \'c0\'a7\'c7\'d1
\f0  
\f1 \'b9\'e8\'bf\'ad
\f0 \
\
\}G;\
\
int index(V* v, char c, int n) \{\
\
	int i;\
\
	for (i = 0; i < n; i++) \{\
\
		if ((v + i)->name == c)\
			break;\
\
	\}\
\
	return i;\
\
\}\
\
inList* getL();\
int DFS();\
int rDFS();\
\
void main() \{\
\
\
	int n, m, i, w;\
	char v1, v2;\
	G g;\
	inList* ltmp, * lttmp;\
\
	scanf("%d%d", &n, &m);\
	getchar();\
\
	for (i = 0; i < 100; i++) \{\
		g.connected[i] = 0;\
	\}\
\
	for (i = 0; i < n; i++) \{\
\
		scanf("%c", &v1);\
		getchar();\
\
		g.v[i].name = v1;\
		g.v[i].L = getL();\
		g.v[i].label = 0; // fresh\
\
	\}\
\
	for (i = 0; i < m; i++) \{\
\
		scanf("%c %c %d", &v1, &v2, &w);\
		getchar();\
\
		g.e[i].v1 = g.v + index(g.v, v1, n);\
		g.e[i].v2 = g.v + index(g.v, v2, n);\
		g.e[i].weight = w;\
\
		ltmp = getL();\
		ltmp->e = g.e + i;\
\
		ltmp->next = g.v[index(g.v, v1, n)].L->next;\
		g.v[index(g.v, v1, n)].L->next = ltmp;\
\
		ltmp = getL();\
		ltmp->e = g.e + i;\
\
		ltmp->next = g.v[index(g.v, v2, n)].L->next;\
		g.v[index(g.v, v2, n)].L->next = ltmp;\
\
	\}\
\
	w = DFS(&g, n);\
\
	printf("%d\\n", w);\
\
	for (i = 0; i < w; i++) \{\
\
		printf(" %d", g.connected[i]);\
\
	\}\
\
	printf("\\n");\
\
	for (i = 0; i < n; i++) \{\
\
		ltmp = g.v[i].L;\
\
		while (ltmp != NULL) \{\
\
			lttmp = ltmp->next;\
			free(ltmp);\
			ltmp = lttmp;\
\
		\}\
\
	\}\
\
\}\
\
inList* getL() \{\
\
	inList* newnode;\
\
	newnode = (inList*)malloc(sizeof(inList));\
\
	newnode->e = NULL;\
	newnode->next = NULL;\
\
	return newnode;\
\
\}\
\
\
\
int DFS(G* g, int n) \{\
\
	int idx = 0, i, j, min, tmp, min_idx;\
\
	*((g->connected) + idx) = rDFS(g, 0, n);\
	idx++;\
\
	for (i = 0; i < n; i++) \{\
\
		if (((g->v) + i)->label == 0) \{\
			*((g->connected) + idx) = rDFS(g, i, n);\
			idx++;\
		\}\
\
	\}\
\
	for (i = idx - 1; i >= 0; i--) \{\
\
		min = *(g->connected);\
		min_idx = 0;\
\
		for (j = 0; j <= i; j++) \{\
\
			if (min > *((g->connected) + j)) \{\
\
				min = *((g->connected) + j);\
				min_idx = j;\
\
			\}\
\
		\}\
\
		tmp = *((g->connected) + i);\
		*((g->connected) + i) = min;\
		*((g->connected) + min_idx) = tmp;\
\
	\}\
\
\
	return idx;\
\
\}\
\
int rDFS(G* g, int s, int n) \{\
\
	V* z;\
	inList* tmp;\
	int vertex_num = 0;\
\
	((g->v) + s)->label = 1; // visited\
\
	tmp = ((g->v) + s)->L->next;\
\
	while (tmp != NULL) \{\
\
		if (tmp->e->v1->name == ((g->v) + s)->name)\
			z = tmp->e->v2;\
		else\
			z = tmp->e->v1;\
\
		if (z->label == 0)\
			vertex_num += rDFS(g, index(g->v,z->name, n), n);\
\
		tmp = tmp->next;\
\
	\}\
\
	return vertex_num + 1;\
\
\}}